{"version":3,"sources":["~lib/rt/common.ts","assembly/game-of-life.ts"],"names":[],"mappings":"4MC4BW,EAAT,EACS,EAAT,EACS,EAAI,EAAJ,CAAT,E,EAGoB,EAAJ,G,EACD,EAAR,E,EAAe,EAAJ,G,EAEV,EAAY,KAAZ,CACA,EAAY,KAAZ,CAFI,EAAgB,SAAhB,E,EAnBA,EAsBD,EAtBc,EAAJ,CAAT,CAsBJ,EAtBI,CAA2B,EAA5B,CAA+B,EAA1C,GAkB2B,E,GAAF,E,IADA,E,GAAF,E,UAaf,EAEE,EAAI,EAAJ,C,EAHF,EAIE,EAAI,EAAJ,C,IAIM,EAAI,EAAJ,C,EACW,EAAI,EAAJ,CAAN,EAAT,G,EACe,EAAI,EAAJ,CAAJ,EAAX,EAAK,EAAL,E,EACG,EAAR,E,EAAW,EAAI,EAAJ,C,EACW,EAAI,EAAJ,CAAN,EAAT,GAMH,EAAK,EArDM,EAAJ,IAAkB,EAAnB,CAAV,GAqDgB,EAAhB,CAA0B,EArDf,GAAkB,EAAnB,CAAV,GAqDoC,EAAd,CAAvB,CArDY,EAgDW,EAAI,EAAJ,CAAJ,EAAX,EAAK,EAAL,EAKuC,EArDnC,CAAkB,EAAnB,CAAV,GAqD0D,EAAhB,CAA3C,CACU,EAtDM,EAAJ,GAsDP,EAtDO,CAAkB,EAAnB,CAAV,GAsDgB,EAAhB,CADD,CArDY,EAsDmC,EAtDnC,CAAkB,EAAnB,CAAV,GAsD0D,EAAhB,CAD3C,CAEK,EAAK,EAvDM,EAAJ,IAAkB,EAAnB,CAAV,GAuDgB,EAAhB,CAFD,CAE2B,EAvDf,GAAkB,EAAnB,CAAV,GAuDoC,EAAd,CAFvB,CArDY,EAuDmC,EAvDnC,CAAkB,EAAnB,CAAV,GAuD0D,EAAhB,CAF3C,CADF,EAMe,EA1DD,GAAkB,EAAnB,CAAV,GA0DH,EACW,EAAP,CAAJ,EAEO,EAAiB,EAAjB,CAA4B,EAA7B,CAAJ,EAvDe,EAAT,GAuDuC,EAvDvC,CAA2B,EAA5B,CAOgB,EAAI,KAAJ,CAgD8B,EAjD9B,EAAL,CAAW,EAAZ,C,EAAqB,E,KAA9B,CACQ,EAAT,CAAD,CAPV,IAAY,EAyDM,EAzDO,EAAJ,CAAT,CAyDG,EAzDH,CAA2B,EAA5B,CAyDU,EAAW,KAAX,CAzDrB,KA4DU,EAAkB,EAAlB,CAAJ,EA5DM,EA4D0B,EA5Db,EAAJ,CAAT,CA4DuB,EA5DvB,CAA2B,EAA5B,CA4D8B,EAAY,KAAZ,CA5DzC,IAAY,EA8DM,EA9DO,EAAJ,CAAT,CA8DG,EA9DH,CAA2B,EAA5B,CAOgB,EAAI,KAAJ,CAuDN,EAxDM,EAAL,CAAW,EAAZ,C,EAAqB,E,KAA9B,CACQ,EAAT,CAAD,CAPV,KAwC2B,E,GAAF,E,IAHA,E,GAAF,E,WAiCN,EAAK,EAAL,C,EACX,EAAgB,EAAhB,CAAJ,EAvEU,EAuEqB,EAvER,EAAJ,CAAT,CAuEiB,EAvEjB,CAA2B,EAA5B,CAuEyB,EAAY,KAAZ,CAvEpC,IAsE+B,E,GAAF,E,MAGZ,EAAK,EAAL,C,EACX,EAAgB,EAAhB,CAAJ,EA1EU,EA0EoB,EA1EP,EAAJ,CAAT,CA0EiB,EA1EjB,CAA2B,EAA5B,CA0EyB,EAAY,KAAZ,CA1EpC,IAyEgC,E,GAAF,E","sourceRoot":"./game-of-life","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","// Configuration imported from JS\ndeclare const BGR_ALIVE: u32;\ndeclare const BGR_DEAD: u32;\ndeclare const BIT_ROT: u32;\n\nvar width: i32, height: i32, offset: i32;\n\n/** Gets an input pixel in the range [0, s]. */\n@inline\nfunction get(x: u32, y: u32): u32 {\n  return load<u32>((y * width + x) << 2);\n}\n\n/** Sets an output pixel in the range [s, 2*s]. */\n@inline\nfunction set(x: u32, y: u32, v: u32): void {\n  store<u32>((offset + y * width + x) << 2, v);\n}\n\n/** Sets an output pixel in the range [s, 2*s] while fading it out. */\n@inline\nfunction rot(x: u32, y: u32, v: u32): void {\n  var alpha = max<i32>((v >> 24) - BIT_ROT, 0);\n  set(x, y, (alpha << 24) | (v & 0x00ffffff));\n}\n\n/** Initializes width and height. Called once from JS. */\nexport function init(w: i32, h: i32): void {\n  width  = w;\n  height = h;\n  offset = w * h;\n\n  // Start by filling output with random live cells.\n  for (let y = 0; y < h; ++y) {\n    for (let x = 0; x < w; ++x) {\n      let c = Math.random() > 0.1\n        ? BGR_DEAD  & 0x00ffffff\n        : BGR_ALIVE | 0xff000000;\n      set(x, y, c);\n    }\n  }\n}\n\n/** Performs one step. Called about 30 times a second from JS. */\nexport function step(): void {\n  var w = width,\n      h = height;\n\n  var hm1 = h - 1, // h - 1\n      wm1 = w - 1; // w - 1\n\n  // The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square\n  // \"cells\", each of which is in one of two possible states, alive or dead.\n  for (let y = 0; y < h; ++y) {\n    let ym1 = y == 0 ? hm1 : y - 1,\n        yp1 = y == hm1 ? 0 : y + 1;\n    for (let x = 0; x < w; ++x) {\n      let xm1 = x == 0 ? wm1 : x - 1,\n          xp1 = x == wm1 ? 0 : x + 1;\n\n      // Every cell interacts with its eight neighbours, which are the cells that are horizontally,\n      // vertically, or diagonally adjacent. Least significant bit indicates alive or dead.\n      let aliveNeighbors = (\n        (get(xm1, ym1) & 1) + (get(x, ym1) & 1) + (get(xp1, ym1) & 1) +\n        (get(xm1, y  ) & 1)                     + (get(xp1, y  ) & 1) +\n        (get(xm1, yp1) & 1) + (get(x, yp1) & 1) + (get(xp1, yp1) & 1)\n      );\n\n      let self = get(x, y);\n      if (self & 1) {\n        // A live cell with 2 or 3 live neighbors rots on to the next generation.\n        if ((aliveNeighbors & 0b1110) == 0b0010) rot(x, y, self);\n        // A live cell with fewer than 2 or more than 3 live neighbors dies.\n        else set(x, y, BGR_DEAD | 0xff000000);\n      } else {\n        // A dead cell with exactly 3 live neighbors becomes a live cell.\n        if (aliveNeighbors == 3) set(x, y, BGR_ALIVE | 0xff000000);\n        // A dead cell with fewer or more than 3 live neighbors just rots.\n        else rot(x, y, self);\n      }\n    }\n  }\n}\n\n/** Fills the row and column indicated by `x` and `y` with random live cells. */\nexport function fill(x: u32, y: u32, p: f64): void {\n  for (let ix = 0; ix < width; ++ix) {\n    if (Math.random() < p) set(ix, y, BGR_ALIVE | 0xff000000);\n  }\n  for (let iy = 0; iy < height; ++iy) {\n    if (Math.random() < p) set(x, iy, BGR_ALIVE | 0xff000000);\n  }\n}\n"]}